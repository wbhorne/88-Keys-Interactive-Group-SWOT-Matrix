<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>88 Keys Interactive SWOT Ranking Exercise (Confidential & Restricted © 88 Keys LLC)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        .app-title {
            font-size: 2.25rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 0.5rem;
        }
        .copyright {
            font-size: 0.875rem;
            color: #718096;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .section-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 1rem;
        }
        .input-group label {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            display: block;
        }
        .input-group select, .input-group input[type="text"], .input-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #2d3748;
            background-color: #edf2f7;
        }
        .btn-primary {
            background-color: #4c51bf;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            cursor: pointer;
            display: inline-block;
        }
        .btn-primary:hover {
            background-color: #5a61d6;
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
            box-shadow: none;
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #ebf4ff;
            color: #2d3748;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.875rem;
        }
        tr:last-child td {
            border-bottom: none;
        }
        tr:hover {
            background-color: #f7fafc;
        }
        .message-box {
            background-color: #fff;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            color: #2d3748;
            display: none;
        }
        .message-box.show {
            display: block;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4c51bf;
            display: none;
        }
        .loading-overlay.show {
            display: flex;
        }
        /* Style for the User ID display */
        #authStatus {
            text-align: right;
            font-size: 0.875rem;
            color: #48bb78;
            padding-bottom: 1rem;
            font-weight: 600;
        }
        /* --- Print-specific styles --- */
        @media print {
            body {
                background-color: #fff;
            }
            .container {
                box-shadow: none;
                padding: 0;
            }
            .p-6.bg-yellow-50, .p-6.bg-blue-50, .p-6.bg-pink-50, .message-box, #authStatus, .loading-overlay, .copyright {
                display: none;
            }
            .p-6.bg-green-50, .p-6.bg-purple-50 {
                display: block !important;
                margin-top: 2rem;
                padding: 0;
                box-shadow: none;
            }
            .section-title {
                margin-top: 1rem;
            }
            .table-container {
                overflow-x: visible;
            }
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, addDoc, onSnapshot, collection, query, where, getDocs, deleteDoc, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances and state
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.currentUserId = null;
        window.isAuthReady = false;
        window.OPTIONS = [];
        const MAX_OPTIONS = 15;
        window.allSubmissions = [];

        // Provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let loadingOverlay, optionsInputFieldsDiv, setOptionsBtn, participantNameInput, rankingInputsDiv, submitRanksBtn, resultsTableBody, submissionsTableHead, submissionsTableBody, messageBox, printResultsBtn, downloadHtmlBtn, companyNameInput, archiveAndResetBtn, authStatusDiv;

        /**
         * Initializes Firebase and authenticates the user. This is a critical
         * function that must be completed before any other Firebase-related code runs.
         */
        async function initializeAndAuthenticateFirebase() {
            try {
                if (authStatusDiv) {
                    authStatusDiv.innerHTML = `<span style="color: #4c51bf;">Initializing Firebase...</span>`;
                }

                // Initialize the app and get service instances
                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // Wait for the auth state to be determined and handle sign-in
                await new Promise((resolve, reject) => {
                    const unsubscribe = onAuthStateChanged(window.auth, async (user) => {
                        unsubscribe(); // Unsubscribe immediately after the first event
                        try {
                            if (!user) {
                                if (authStatusDiv) {
                                    authStatusDiv.innerHTML = `<span style="color: #6366f1;">Authenticating...</span>`;
                                }
                                if (initialAuthToken) {
                                    await signInWithCustomToken(window.auth, initialAuthToken);
                                } else {
                                    await signInAnonymously(window.auth);
                                }
                            }
                            window.currentUserId = window.auth.currentUser ? window.auth.currentUser.uid : null;
                            if (!window.currentUserId) {
                                throw new Error("Authentication failed: No user ID found.");
                            }
                            if (authStatusDiv) {
                                authStatusDiv.innerHTML = `✅ Logged in with User ID: <strong>${window.currentUserId}</strong>`;
                            }
                            console.log("Firebase Auth Ready. User ID:", window.currentUserId);
                            window.isAuthReady = true;
                            resolve();
                        } catch (error) {
                            console.error("Error during authentication:", error);
                            if (authStatusDiv) {
                                authStatusDiv.innerHTML = `<span style="color: #ef4444;">❌ Authentication failed. Please refresh.</span>`;
                            }
                            showMessage("Authentication failed. Please refresh the page.", 10000);
                            window.isAuthReady = false;
                            reject(error);
                        }
                    });
                });
            } catch (error) {
                console.error("Critical error initializing Firebase:", error);
                if (authStatusDiv) {
                    authStatusDiv.innerHTML = `<span style="color: #ef4444;">❌ Critical Firebase error.</span>`;
                }
                showMessage("A critical error occurred. Some features will not work.", 10000);
                window.isAuthReady = false;
                throw error;
            }
        }

        /**
         * Sets up real-time listeners for options and submissions from Firestore.
         * This function should only be called after authentication is ready.
         */
        function setupFirestoreListeners() {
            console.log("Setting up Firestore listeners...");
            const optionsDocRef = doc(window.db, `artifacts/${appId}/public/data/ranking_options`, 'current_options');
            onSnapshot(optionsDocRef, (docSnap) => {
                const newOptions = docSnap.exists() ? (docSnap.data().options || []) : [];
                if (JSON.stringify(newOptions) !== JSON.stringify(window.OPTIONS)) {
                    window.OPTIONS = newOptions;
                    console.log("Options updated from Firestore:", window.OPTIONS);
                    window.initializeRankingInputs();
                    window.renderGroupRanking();
                    window.renderAllSubmissions();
                }
            }, (error) => {
                console.error("Error listening to options:", error);
                showMessage("Failed to load options in real-time.", 5000);
            });

            const submissionsColRef = collection(window.db, `artifacts/${appId}/public/data/ranking_submissions`);
            onSnapshot(submissionsColRef, (snapshot) => {
                const newSubmissions = [];
                snapshot.forEach(doc => {
                    newSubmissions.push({ id: doc.id, ...doc.data() });
                });
                if (JSON.stringify(newSubmissions) !== JSON.stringify(window.allSubmissions)) {
                    window.allSubmissions = newSubmissions;
                    console.log("Submissions updated from Firestore:", window.allSubmissions);
                    window.renderGroupRanking();
                    window.renderAllSubmissions();
                }
            }, (error) => {
                console.error("Error listening to submissions:", error);
                showMessage("Failed to load submissions in real-time.", 5000);
            });
        }

        // Helper function to show a temporary message box.
        function showMessage(message, duration = 3000) {
            if (messageBox) {
                messageBox.textContent = message;
                messageBox.classList.add('show');
                setTimeout(() => {
                    if (messageBox) {
                       messageBox.classList.remove('show');
                    }
                }, duration);
            }
        }

        // Toggles the loading overlay visibility.
        window.toggleLoading = function(show) {
            if (loadingOverlay) {
                if (show) {
                    loadingOverlay.classList.add('show');
                } else {
                    loadingOverlay.classList.remove('show');
                }
            }
        };

        // Renders the input fields for defining options.
        window.renderOptionInputFields = function() {
            if (!optionsInputFieldsDiv) return;
            optionsInputFieldsDiv.innerHTML = '';
            for (let i = 0; i < MAX_OPTIONS; i++) {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                inputGroup.innerHTML = `
                    <label for="option${i + 1}">Option ${i + 1}:</label>
                    <input type="text" id="option${i + 1}" placeholder="Enter option name" class="rounded-md focus:ring-yellow-500 focus:border-yellow-500">
                `;
                optionsInputFieldsDiv.appendChild(inputGroup);
            }
        };

        // Handles setting the options in Firestore. Includes a defensive check.
        async function setOptionsFromInput() {
            if (!window.isAuthReady) {
                showMessage("App is not ready. Please wait for initialization to complete.", 5000);
                return;
            }
            window.toggleLoading(true);
            try {
                const newOptions = [];
                for (let i = 0; i < MAX_OPTIONS; i++) {
                    const inputField = document.getElementById(`option${i + 1}`);
                    if (inputField && inputField.value.trim() !== '') {
                        newOptions.push(inputField.value.trim());
                    }
                }

                if (newOptions.length === 0) {
                    showMessage("Please enter at least one option.");
                    return;
                }

                const uniqueOptions = new Set(newOptions.map(opt => opt.toLowerCase()));
                if (uniqueOptions.size !== newOptions.length) {
                    showMessage("Duplicate option names detected. Please ensure all options are unique.");
                    return;
                }

                const optionsDocRef = doc(window.db, `artifacts/${window.appId}/public/data/ranking_options`, 'current_options');
                await setDoc(optionsDocRef, { options: newOptions, lastUpdated: new Date() });

                showMessage("Options updated successfully!");
                await clearAllSubmissions();
            } catch (error) {
                console.error("Error setting options:", error);
                showMessage("Failed to set options. Please try again.", 5000);
            } finally {
                window.toggleLoading(false);
            }
        }

        // Clears all submissions from the database.
        async function clearAllSubmissions() {
             if (!window.isAuthReady) {
                showMessage("App is not ready. Please wait for initialization to complete.", 5000);
                return;
            }
            window.toggleLoading(true);
            try {
                const submissionsColRef = collection(window.db, `artifacts/${window.appId}/public/data/ranking_submissions`);
                const q = query(submissionsColRef);
                const querySnapshot = await getDocs(q);

                const deletePromises = [];
                querySnapshot.forEach((doc) => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);
                console.log("All submissions cleared from Firestore.");
                showMessage("All submissions cleared.", 3000);
            } catch (error) {
                console.error("Error clearing submissions:", error);
                showMessage("Failed to clear submissions. Please try again.", 5000);
            } finally {
                window.toggleLoading(false);
            }
        }

        // Archives the current session and resets the data.
        async function archiveAndReset() {
             if (!window.isAuthReady) {
                showMessage("App is not ready. Please wait for initialization to complete.", 5000);
                return;
            }
            window.toggleLoading(true);

            const companyName = companyNameInput.value.trim();
            if (!companyName) {
                showMessage("Please enter a company or project name to archive the results.", 5000);
                window.toggleLoading(false);
                return;
            }

            try {
                await runTransaction(window.db, async (transaction) => {
                    const optionsDocRef = doc(window.db, `artifacts/${window.appId}/public/data/ranking_options`, 'current_options');
                    const optionsSnap = await transaction.get(optionsDocRef);
                    const submissionsColRef = collection(window.db, `artifacts/${window.appId}/public/data/ranking_submissions`);
                    const submissionsSnap = await getDocs(submissionsColRef);

                    if (!optionsSnap.exists() && submissionsSnap.empty) {
                        showMessage("There is no data to archive. Resetting session...", 3000);
                        return;
                    }

                    const archiveSessionId = companyName + '_' + new Date().getTime();
                    const archiveDocRef = doc(window.db, `artifacts/${window.appId}/public/data/archived_sessions`, archiveSessionId);

                    const archivedData = {
                        company: companyName,
                        options: optionsSnap.exists() ? optionsSnap.data().options : [],
                        timestamp: new Date()
                    };
                    transaction.set(archiveDocRef, archivedData);

                    const archivedSubmissionsColRef = collection(archiveDocRef, 'submissions');
                    submissionsSnap.forEach(submissionDoc => {
                        transaction.set(doc(archivedSubmissionsColRef, submissionDoc.id), submissionDoc.data());
                    });

                    transaction.set(optionsDocRef, { options: [] });
                    submissionsSnap.forEach(submissionDoc => {
                        transaction.delete(submissionDoc.ref);
                    });
                });

                showMessage(`Results for '${companyName}' have been archived and the session has been reset!`);
                if (companyNameInput) companyNameInput.value = '';

            } catch (e) {
                console.error("Transaction failed: ", e);
                showMessage("Failed to archive and reset the session. Please try again.", 5000);
            } finally {
                window.toggleLoading(false);
            }
        }

        // Dynamically generates the ranking input fields.
        window.initializeRankingInputs = function() {
            if (!rankingInputsDiv) return;
            rankingInputsDiv.innerHTML = '';
            if (window.OPTIONS.length === 0) {
                rankingInputsDiv.innerHTML = '<p class="text-gray-600">Please define options in the "Define Ranking Options" section first.</p>';
                return;
            }
            window.OPTIONS.forEach(option => {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'input-group';
                const safeId = encodeURIComponent(option).replace(/%/g, '_');
                inputGroup.innerHTML = `
                    <label for="${safeId}">${option}:</label>
                    <select id="${safeId}" class="rounded-md focus:ring-blue-500 focus:border-blue-500">
                        <option value="">Select Rank</option>
                        ${window.OPTIONS.map((_, index) => `<option value="${index + 1}">${index + 1}</option>`).join('')}
                    </select>
                `;
                rankingInputsDiv.appendChild(inputGroup);
            });
        };

        // Calculates the overall group ranking based on submissions.
        function calculateGroupRanking() {
            const optionScores = {};
            window.OPTIONS.forEach(option => {
                optionScores[option] = 0;
            });

            window.allSubmissions.forEach(submission => {
                window.OPTIONS.forEach(option => {
                    const rank = submission.ranks[option];
                    if (rank) {
                        optionScores[option] += (window.OPTIONS.length - rank + 1);
                    }
                });
            });

            let rankedOptions = Object.keys(optionScores).map(option => {
                const totalScore = optionScores[option];
                const numberOfParticipants = window.allSubmissions.length;
                const averageScore = numberOfParticipants > 0 ? (totalScore / numberOfParticipants) : 0;
                return {
                    option: option,
                    score: totalScore,
                    averageScore: parseFloat(averageScore.toFixed(2))
                };
            });

            rankedOptions.sort((a, b) => b.score - a.score);

            rankedOptions.forEach((item, index) => {
                if (index > 0 && item.score === rankedOptions[index - 1].score) {
                    item.rank = rankedOptions[index - 1].rank;
                } else {
                    item.rank = index + 1;
                }
            });
            return rankedOptions;
        }

        // Renders the group ranking table.
        window.renderGroupRanking = function() {
            if (!resultsTableBody) return;
            const rankedOptions = calculateGroupRanking();
            resultsTableBody.innerHTML = '';

            if (window.allSubmissions.length === 0) {
                resultsTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-gray-500">No submissions yet. Be the first!</td></tr>`;
                return;
            }

            rankedOptions.forEach(item => {
                const row = resultsTableBody.insertRow();
                row.innerHTML = `
                    <td class="font-bold text-blue-700">${item.rank}</td>
                    <td>${item.option}</td>
                    <td>${item.score}</td>
                    <td>${item.averageScore}</td>
                `;
            });
        };

        // Renders the table of all individual submissions.
        window.renderAllSubmissions = function() {
            if (!submissionsTableHead || !submissionsTableBody) return;
            submissionsTableHead.innerHTML = '<th>Participant</th>';
            submissionsTableBody.innerHTML = '';

            window.OPTIONS.forEach(option => {
                const th = document.createElement('th');
                th.textContent = option;
                submissionsTableHead.appendChild(th);
            });

            if (window.allSubmissions.length === 0) {
                submissionsTableBody.innerHTML = `<tr><td colspan="${window.OPTIONS.length + 1}" class="text-center text-gray-500">No submissions yet.</td></tr>`;
                return;
            }

            window.allSubmissions.forEach(submission => {
                const row = submissionsTableBody.insertRow();
                const participantCell = row.insertCell();
                participantCell.textContent = submission.name;

                window.OPTIONS.forEach(option => {
                    const rankCell = row.insertCell();
                    rankCell.textContent = submission.ranks[option] || '-';
                });
            });
        };

        // Submits a single participant's ranking.
        async function handleSubmitRanks() {
            if (!window.isAuthReady) {
                showMessage("App is not ready. Please wait for initialization to complete.", 5000);
                return;
            }
            const participantName = participantNameInput.value.trim();
            if (!participantName) {
                showMessage("Please enter your name.");
                return;
            }
            if (window.OPTIONS.length === 0) {
                showMessage("Please define options in the 'Define Ranking Options' section first.");
                return;
            }

            const currentRanks = {};
            const selectedRanks = new Set();
            let allRanked = true;

            window.OPTIONS.forEach(option => {
                const safeId = encodeURIComponent(option).replace(/%/g, '_');
                const selectElement = document.getElementById(safeId);

                if (!selectElement) {
                    allRanked = false;
                    return;
                }
                const rank = selectElement.value;
                if (!rank) {
                    allRanked = false;
                } else if (selectedRanks.has(rank)) {
                    showMessage(`Duplicate rank '${rank}' detected. Each option must have a unique rank.`);
                    allRanked = false;
                    return;
                } else {
                    currentRanks[option] = parseInt(rank);
                    selectedRanks.add(rank);
                }
            });

            if (!allRanked) {
                if (selectedRanks.size !== window.OPTIONS.length) {
                     showMessage("Please rank all options uniquely.");
                }
                return;
            }

            window.toggleLoading(true);
            try {
                const submissionsColRef = collection(window.db, `artifacts/${window.appId}/public/data/ranking_submissions`);

                const q = query(submissionsColRef, where("name", "==", participantName));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const docToUpdate = querySnapshot.docs[0];
                    await setDoc(doc(submissionsColRef, docToUpdate.id), {
                        name: participantName,
                        ranks: currentRanks,
                        timestamp: new Date()
                    });
                    showMessage(`Updated ranks for ${participantName}!`);
                } else {
                    await addDoc(submissionsColRef, {
                        name: participantName,
                        ranks: currentRanks,
                        timestamp: new Date()
                    });
                    showMessage(`Thanks, ${participantName}! Your ranks have been submitted.`);
                }
            } catch (error) {
                console.error("Error submitting ranks:", error);
                showMessage("Failed to submit ranks. Please try again.", 5000);
            } finally {
                if (participantNameInput) participantNameInput.value = '';
                window.initializeRankingInputs();
                window.toggleLoading(false);
            }
        }

        /**
         * Downloads the current results as an HTML file.
         */
        function downloadHTMLResults() {
            if (!resultsTableBody || !submissionsTableBody || !companyNameInput) {
                showMessage("Results not available to download yet.", 3000);
                return;
            }
            const resultsTableHtml = document.getElementById('resultsTable').outerHTML;
            const submissionsTableHtml = document.getElementById('submissionsTable').outerHTML;
            const companyName = companyNameInput.value.trim() || 'Untitled Session';

            const htmlContent = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>Ranking Results - ${companyName}</title>
                    <style>
                        body { font-family: sans-serif; margin: 2rem; }
                        h1, h2 { color: #2d3748; }
                        table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
                        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #e2e8f0; }
                        th { background-color: #ebf4ff; color: #2d3748; font-weight: 700; text-transform: uppercase; }
                        tr:last-child td { border-bottom: none; }
                        .text-blue-700 { color: #2b6cb0; }
                        .font-bold { font-weight: 700; }
                    </style>
                </head>
                <body>
                    <h1>Group Ranking Results for: ${companyName}</h1>
                    <p>Generated on: ${new Date().toLocaleString()}</p>
                    <h2>Overall Ranking</h2>
                    ${resultsTableHtml}
                    <h2>All Participant Submissions</h2>
                    ${submissionsTableHtml}
                </body>
                </html>
            `;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `Ranking_Results_${companyName.replace(/ /g, '_')}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        // Initial setup on page load
        window.addEventListener('DOMContentLoaded', async () => {
            // Get references to DOM elements
            loadingOverlay = document.getElementById('loadingOverlay');
            optionsInputFieldsDiv = document.getElementById('optionsInputFields');
            setOptionsBtn = document.getElementById('setOptionsBtn');
            participantNameInput = document.getElementById('participantName');
            rankingInputsDiv = document.getElementById('rankingInputs');
            submitRanksBtn = document.getElementById('submitRanksBtn');
            resultsTableBody = document.querySelector('#resultsTable tbody');
            submissionsTableHead = document.querySelector('#submissionsTable thead tr');
            submissionsTableBody = document.querySelector('#submissionsTable tbody');
            messageBox = document.getElementById('messageBox');
            printResultsBtn = document.getElementById('printResultsBtn');
            downloadHtmlBtn = document.getElementById('downloadHtmlBtn');
            companyNameInput = document.getElementById('companyName');
            archiveAndResetBtn = document.getElementById('archiveAndResetBtn');
            authStatusDiv = document.getElementById('authStatus');

            // Hide the loading overlay immediately
            window.toggleLoading(false);

            // Immediately render the options input fields
            window.renderOptionInputFields();

            // Attach event listeners
            if (setOptionsBtn) setOptionsBtn.addEventListener('click', setOptionsFromInput);
            if (submitRanksBtn) submitRanksBtn.addEventListener('click', handleSubmitRanks);
            if (printResultsBtn) printResultsBtn.addEventListener('click', () => {
                window.print();
            });
            if (downloadHtmlBtn) downloadHtmlBtn.addEventListener('click', downloadHTMLResults);
            if (archiveAndResetBtn) archiveAndResetBtn.addEventListener('click', archiveAndReset);

            // CRITICAL: Initialize and authenticate Firebase first.
            // This async call blocks the rest of the application setup until it's done.
            try {
                await initializeAndAuthenticateFirebase();
                // If the initialization was successful, set up the real-time listeners.
                if (window.isAuthReady) {
                    setupFirestoreListeners();
                }
            } catch (error) {
                // The catch block in the initialization function will handle the message.
                console.error("Application startup failed.", error);
            }
        });
    </script>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        Loading...
    </div>

    <div class="container">
        <h1 class="app-title">88 Keys Interactive SWOT Ranking Exercise</h1>
        <p class="copyright">© 88 Keys LLC (Confidential & Restricted)</p>
        <div id="authStatus"></div>
        <div class="message-box" id="messageBox"></div>

        <!-- Section to Define Ranking Options -->
        <div class="p-6 bg-yellow-50 rounded-lg">
            <h2 class="section-title text-yellow-800">1. Define Ranking Options</h2>
            <p class="text-gray-600 mb-4">
                Enter the options you want to rank. These could be ideas, projects, or any items for a SWOT analysis.
            </p>
            <div id="optionsInputFields" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <!-- Option input fields will be dynamically generated here -->
            </div>
            <div class="flex justify-end">
                <button id="setOptionsBtn" class="btn-primary bg-yellow-500 hover:bg-yellow-600">
                    Set Options
                </button>
            </div>
        </div>

        <!-- Section for Participant Ranking -->
        <div class="p-6 bg-blue-50 rounded-lg">
            <h2 class="section-title text-blue-800">2. Your Ranking</h2>
            <p class="text-gray-600 mb-4">
                Enter your name and assign a unique rank to each option. A rank of 1 is the highest.
            </p>
            <div class="input-group mb-4">
                <label for="participantName">Your Name (Required):</label>
                <input type="text" id="participantName" placeholder="e.g., Jane Doe" class="rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div id="rankingInputs" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <!-- Ranking input fields will be dynamically generated here -->
            </div>
            <div class="flex justify-end">
                <button id="submitRanksBtn" class="btn-primary bg-blue-500 hover:bg-blue-600">
                    Submit My Ranks
                </button>
            </div>
        </div>

        <!-- Section for Group Ranking Results -->
        <div class="p-6 bg-green-50 rounded-lg">
            <h2 class="section-title text-green-800">3. Group Ranking Results</h2>
            <p class="text-gray-600 mb-4">
                This table shows the combined scores and final rankings from all participants.
            </p>
            <div class="table-container">
                <table class="min-w-full" id="resultsTable">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Option</th>
                            <th>Total Score</th>
                            <th>Average Score</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        <tr><td colspan="4" class="text-center text-gray-500">No submissions yet. Be the first!</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Section to view all submissions -->
        <div class="p-6 bg-purple-50 rounded-lg">
            <h2 class="section-title text-purple-800">4. All Participant Submissions</h2>
            <p class="text-gray-600 mb-4">
                Here's a breakdown of how each participant ranked the options.
            </p>
            <div class="table-container">
                <table class="min-w-full" id="submissionsTable">
                    <thead>
                        <tr>
                            <!-- Headers dynamically generated -->
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Submissions dynamically generated -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Section for Session Management and Reporting -->
        <div class="p-6 bg-pink-50 rounded-lg">
            <h2 class="section-title text-pink-800">5. Manage & Report</h2>
            <p class="text-gray-600 mb-4">
                Enter a company name to save your session, download the report, or archive the data for a fresh start.
            </p>
            <div class="input-group mb-4">
                <label for="companyName">Company/Project Name:</label>
                <input type="text" id="companyName" placeholder="e.g., Acme Inc. Q3 Strategy" class="rounded-md focus:ring-pink-500 focus:border-pink-500">
            </div>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="downloadHtmlBtn" class="btn-primary bg-pink-500 hover:bg-pink-600 flex-1">
                    Download HTML Report
                </button>
                <button id="printResultsBtn" class="btn-primary bg-pink-500 hover:bg-pink-600 flex-1">
                    Print Report
                </button>
                <button id="archiveAndResetBtn" class="btn-primary bg-red-500 hover:bg-red-600 flex-1">
                    Archive & Reset Session
                </button>
            </div>
        </div>
    </div>
</body>
</html>
